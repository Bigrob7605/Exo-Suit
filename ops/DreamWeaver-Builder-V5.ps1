# DreamWeaver-Builder-V5.ps1
# Agent Exo-Suit V5.0 "Builder of Dreams" - Phase 1 Foundation
# Code Generation Framework: Generate code from markdown descriptions

param(
    [string]$InputFile = "",
    [string]$OutputPath = "./generated_code",
    [string]$Language = "python",
    [switch]$Verbose,
    [switch]$GenerateTests,
    [switch]$ValidateOutput
)

# =============================================================================
# DREAMWEAVER BUILDER V5.0 - CODE GENERATION FRAMEWORK
# =============================================================================
# Purpose: Generate working code from markdown specifications
# Component: Phase 1 Foundation - Code Generation Framework
# Status: Implementation Phase
# =============================================================================

# Import required modules
Import-Module Microsoft.PowerShell.Utility

# =============================================================================
# CONFIGURATION & SETUP
# =============================================================================

$ScriptVersion = "5.0.0"
$ScriptName = "DreamWeaver-Builder-V5"
$ScriptCodename = "Code Generation Framework"

# Create output directory if it doesn't exist
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# =============================================================================
# CODE TEMPLATES
# =============================================================================

$CodeTemplates = @{
    "python" = @{
        "class" = @"
class {ClassName}:
    """{Description}"""
    
    def __init__(self{ConstructorParams}):
{ConstructorBody}
    
{Methods}
"@
        "function" = @"
def {FunctionName}({Parameters}):
    """{Description}"""
{FunctionBody}
    return {ReturnValue}
"@
        "module" = @"
"""
{ModuleName}
{Description}

Author: Generated by DreamWeaver Builder V5.0
Date: {Date}
"""

{Imports}

{Classes}

{Functions}

if __name__ == "__main__":
    {MainCode}
"@
    }
    
    "powershell" = @{
        "function" = @"
function {FunctionName} {{
    <#
    .SYNOPSIS
        {Description}
    
    .DESCRIPTION
        {DetailedDescription}
    
    .PARAMETER {Parameters}
        {ParameterDescriptions}
    
    .EXAMPLE
        {Example}
    
    .NOTES
        Generated by DreamWeaver Builder V5.0
    #>
    param(
{ParamBlock}
    )
    
{FunctionBody}
    
    return {ReturnValue}
}}
"@
        "script" = @"
<#
.SYNOPSIS
    {ScriptName}
    
.DESCRIPTION
    {Description}
    
.AUTHOR
    Generated by DreamWeaver Builder V5.0
    
.DATE
    {Date}
#>

{Imports}

{Configuration}

{Functions}

{MainExecution}
"@
    }
    
    "javascript" = @{
        "class" = @"
/**
 * {ClassName}
 * {Description}
 * 
 * Generated by DreamWeaver Builder V5.0
 * Date: {Date}
 */
class {ClassName} {{
    constructor({ConstructorParams}) {{
{ConstructorBody}
    }}
    
{Methods}
}}

module.exports = {ClassName};
"@
        "function" = @"
/**
 * {FunctionName}
 * {Description}
 * 
 * @param {Parameters} - {ParameterDescriptions}
 * @returns {ReturnType} - {ReturnDescription}
 */
function {FunctionName}({Parameters}) {{
{FunctionBody}
    return {ReturnValue};
}}

module.exports = {FunctionName};
"@
    }
}

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

function Write-Log {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    
    if ($Verbose) {
        Write-Host $logMessage
    }
    
    # Add to log file
    $logFile = Join-Path $OutputPath "dreamweaver_builder.log"
    Add-Content -Path $logFile -Value $logMessage
}

function Initialize-Builder {
    Write-Log "Initializing DreamWeaver Builder V5.0 - Code Generation Framework" "INFO"
    Write-Log "Script Version: $ScriptVersion" "INFO"
    Write-Log "Script Codename: $ScriptCodename" "INFO"
    Write-Log "Output Path: $OutputPath" "INFO"
    Write-Log "Target Language: $Language" "INFO"
    
    # Validate language support
    if ($CodeTemplates.ContainsKey($Language)) {
        Write-Log "Language '$Language' is supported" "INFO"
    } else {
        Write-Log "Language '$Language' is not supported. Available: $($CodeTemplates.Keys -join ', ')" "WARN"
        $Language = "python"  # Default fallback
        Write-Log "Falling back to Python" "INFO"
    }
    
    # Check for required tools
    try {
        $pythonVersion = python --version 2>&1
        Write-Log "Python detected: $pythonVersion" "INFO"
    }
    catch {
        Write-Log "Python not found - some features may be limited" "WARN"
    }
}

function Parse-MarkdownSpecification {
    param([string]$FilePath)
    
    Write-Log "Parsing markdown specification: $FilePath" "INFO"
    
    try {
        $content = Get-Content -Path $FilePath -Raw -Encoding UTF8
        
        # Extract specification components
        $spec = @{
            Title = ""
            Description = ""
            Requirements = @()
            Classes = @()
            Functions = @()
            DataStructures = @()
            Examples = @()
            Dependencies = @()
        }
        
        # Extract title
        $titleMatch = [regex]::Match($content, '#\s+(.+)$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
        if ($titleMatch.Success) {
            $spec.Title = $titleMatch.Groups[1].Value.Trim()
        }
        
        # Extract description
        $descMatch = [regex]::Match($content, '##\s*Description?\s*\n+(.+?)(?=\n##|\n###|\n$)', [System.Text.RegularExpressions.RegexOptions]::Singleline)
        if ($descMatch.Success) {
            $spec.Description = $descMatch.Groups[1].Value.Trim()
        }
        
        # Extract requirements
        $reqMatches = [regex]::Matches($content, '-\s*(.+?)(?=\n-|\n##|\n###|\n$)', [System.Text.RegularExpressions.RegexOptions]::Singleline)
        foreach ($match in $reqMatches) {
            $spec.Requirements += $match.Groups[1].Value.Trim()
        }
        
        # Extract class definitions
        $classMatches = [regex]::Matches($content, '###\s*Class:\s*(.+?)(?=\n###|\n##|\n$)', [System.Text.RegularExpressions.RegexOptions]::Singleline)
        foreach ($match in $classMatches) {
            $classContent = $match.Groups[1].Value.Trim()
            $className = [regex]::Match($classContent, '(.+?)(?:\n|$)').Groups[1].Value.Trim()
            $spec.Classes += @{
                Name = $className
                Content = $classContent
            }
        }
        
        # Extract function definitions
        $funcMatches = [regex]::Matches($content, '###\s*Function:\s*(.+?)(?=\n###|\n##|\n$)', [System.Text.RegularExpressions.RegexOptions]::Singleline)
        foreach ($match in $funcMatches) {
            $funcContent = $match.Groups[1].Value.Trim()
            $funcName = [regex]::Match($funcContent, '(.+?)(?:\n|$)').Groups[1].Value.Trim()
            $spec.Functions += @{
                Name = $funcName
                Content = $funcContent
            }
        }
        
        Write-Log "Parsed specification: $($spec.Title)" "INFO"
        Write-Log "Classes found: $($spec.Classes.Count)" "INFO"
        Write-Log "Functions found: $($spec.Functions.Count)" "INFO"
        
        return $spec
    }
    catch {
        Write-Log "Error parsing specification: $($_.Exception.Message)" "ERROR"
        return $null
    }
}

function Generate-CodeFromSpec {
    param(
        [hashtable]$Specification,
        [string]$Language
    )
    
    Write-Log "Generating code from specification for language: $Language" "INFO"
    
    if (!$CodeTemplates.ContainsKey($Language)) {
        Write-Log "Unsupported language: $Language" "ERROR"
        return $null
    }
    
    $generatedCode = @()
    
    # Generate main module/script
    $mainTemplate = $CodeTemplates[$Language]["module"]
    if (!$mainTemplate) { $mainTemplate = $CodeTemplates[$Language]["script"] }
    
    if ($mainTemplate) {
        $mainCode = $mainTemplate -replace "{ModuleName}", $Specification.Title
        $mainCode = $mainCode -replace "{Description}", $Specification.Description
        $mainCode = $mainCode -replace "{Date}", (Get-Date -Format "yyyy-MM-dd")
        $mainCode = $mainCode -replace "{Imports}", ""
        $mainCode = $mainCode -replace "{Classes}", ""
        $mainCode = $mainCode -replace "{Functions}", ""
        $mainCode = $mainCode -replace "{MainCode}", "# Main execution code here"
        
        $generatedCode += @{
            FileName = "main." + (Get-FileExtension $Language)
            Content = $mainCode
            Type = "main"
        }
    }
    
    # Generate classes
    foreach ($class in $Specification.Classes) {
        $classTemplate = $CodeTemplates[$Language]["class"]
        if ($classTemplate) {
            $classCode = $classTemplate -replace "{ClassName}", $class.Name
            $classCode = $classCode -replace "{Description}", $class.Content
            $classCode = $classCode -replace "{ConstructorParams}", ""
            $classCode = $classCode -replace "{ConstructorBody}", "        pass"
            $classCode = $classCode -replace "{Methods}", "    def example_method(self):n        pass"
            
            $generatedCode += @{
                FileName = $class.Name + "." + (Get-FileExtension $Language)
                Content = $classCode
                Type = "class"
            }
        }
    }
    
    # Generate functions
    foreach ($func in $Specification.Functions) {
        $funcTemplate = $CodeTemplates[$Language]["function"]
        if ($funcTemplate) {
            $funcCode = $funcTemplate -replace "{FunctionName}", $func.Name
            $funcCode = $funcCode -replace "{Description}", $func.Content
            $funcCode = $funcCode -replace "{Parameters}", ""
            $funcCode = $funcCode -replace "{FunctionBody}", "    pass"
            $funcCode = $funcCode -replace "{ReturnValue}", "None"
            
            $generatedCode += @{
                FileName = $func.Name + "." + (Get-FileExtension $Language)
                Content = $funcCode
                Type = "function"
            }
        }
    }
    
    Write-Log "Generated $($generatedCode.Count) code files" "INFO"
    return $generatedCode
}

function Get-FileExtension {
    param([string]$Language)
    
    $extensions = @{
        "python" = "py"
        "powershell" = "ps1"
        "javascript" = "js"
        "typescript" = "ts"
        "java" = "java"
        "csharp" = "cs"
        "cpp" = "cpp"
        "c" = "c"
    }
    
    if ($extensions.ContainsKey($Language)) {
        return $extensions[$Language]
    } else {
        return "txt"
    }
}

function Write-GeneratedCode {
    param([array]$GeneratedCode)
    
    Write-Log "Writing generated code files to: $OutputPath" "INFO"
    
    $writtenFiles = @()
    
    foreach ($codeFile in $GeneratedCode) {
        $filePath = Join-Path $OutputPath $codeFile.FileName
        
        try {
            Set-Content -Path $filePath -Value $codeFile.Content -Encoding UTF8
            Write-Log "Generated: $($codeFile.FileName)" "INFO"
            
            $writtenFiles += @{
                FileName = $codeFile.FileName
                FilePath = $filePath
                Type = $codeFile.Type
                Size = (Get-Item $filePath).Length
            }
        }
        catch {
            Write-Log "Error writing file $($codeFile.FileName): $($_.Exception.Message)" "ERROR"
        }
    }
    
    return $writtenFiles
}

function Generate-Tests {
    param(
        [array]$GeneratedCode,
        [string]$Language
    )
    
    if (!$GenerateTests) { return @() }
    
    Write-Log "Generating test files for generated code" "INFO"
    
    $testFiles = @()
    
    foreach ($codeFile in $GeneratedCode) {
        if ($codeFile.Type -eq "main") { continue }
        
        $testContent = ""
        
        switch ($Language) {
            "python" {
                $testContent = @"
import unittest
from $($codeFile.FileName.Replace('.py', '')) import *

class Test$($codeFile.FileName.Replace('.py', '').Replace('_', '').ToUpper()) (unittest.TestCase):
    def setUp(self):
        pass
    
    def test_basic_functionality(self):
        """Test basic functionality"""
        self.assertTrue(True)  # Placeholder test
        
    def tearDown(self):
        pass

if __name__ == '__main__':
    unittest.main()
"@
            }
            "powershell" {
                $testContent = @"
Describe "Test $($codeFile.FileName.Replace('.ps1', ''))" {
    BeforeAll {
        # Setup code here
    }
    
    It "Should have basic functionality" {
        $true | Should -Be $true  # Placeholder test
    }
    
    AfterAll {
        # Cleanup code here
    }
}
"@
            }
            "javascript" {
                $testContent = @"
const assert = require('assert');
const { $($codeFile.FileName.Replace('.js', '')) } = require('./$($codeFile.FileName)');

describe('$($codeFile.FileName.Replace('.js', ''))', function() {
    it('should have basic functionality', function() {
        assert.strictEqual(true, true);  // Placeholder test
    });
});
"@
            }
        }
        
        if ($testContent) {
            $testFileName = "test_$($codeFile.FileName)"
            $testFilePath = Join-Path $OutputPath $testFileName
            
            try {
                Set-Content -Path $testFilePath -Value $testContent -Encoding UTF8
                Write-Log "Generated test: $testFileName" "INFO"
                
                $testFiles += @{
                    FileName = $testFileName
                    FilePath = $testFilePath
                    Type = "test"
                    Size = (Get-Item $testFilePath).Length
                }
            }
            catch {
                Write-Log ("Error writing test file " + $testFileName + ": " + $_.Exception.Message) "ERROR"
            }
        }
    }
    
    return $testFiles
}

function Validate-GeneratedCode {
    param([array]$GeneratedCode)
    
    if (!$ValidateOutput) { return @{ Valid = $true; Issues = @() } }
    
    Write-Log "Validating generated code" "INFO"
    
    $validation = @{
        Valid = $true
        Issues = @()
        Summary = @{
            TotalFiles = $GeneratedCode.Count
            ValidFiles = 0
            InvalidFiles = 0
            Issues = 0
        }
    }
    
    foreach ($codeFile in $GeneratedCode) {
        $fileIssues = @()
        
        # Basic validation checks
        if ($codeFile.Content.Length -eq 0) {
            $fileIssues += "Empty file content"
        }
        
        if ($codeFile.Content -notmatch '\w') {
            $fileIssues += "No meaningful content"
        }
        
        # Language-specific validation
        switch ($codeFile.Type) {
            "class" {
                if ($codeFile.Content -notmatch 'class\s+\w+') {
                    $fileIssues += "Missing class definition"
                }
            }
            "function" {
                if ($codeFile.Content -notmatch 'def\s+\w+|function\s+\w+') {
                    $fileIssues += "Missing function definition"
                }
            }
        }
        
        if ($fileIssues.Count -gt 0) {
            $validation.Valid = $false
            $validation.Summary.InvalidFiles++
            $validation.Issues += @{
                FileName = $codeFile.FileName
                Issues = $fileIssues
            }
        } else {
            $validation.Summary.ValidFiles++
        }
        
        $validation.Summary.Issues += $fileIssues.Count
    }
    
    Write-Log "Validation complete: $($validation.Summary.ValidFiles)/$($validation.Summary.TotalFiles) files valid" "INFO"
    return $validation
}

function Generate-BuildReport {
    param(
        [hashtable]$Specification,
        [array]$GeneratedCode,
        [array]$TestFiles,
        [hashtable]$Validation
    )
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $reportFile = Join-Path $OutputPath "dreamweaver_build_report_$timestamp.md"
    
    Write-Log "Generating build report: $reportFile" "INFO"
    
    $report = @"
# DreamWeaver Builder V5.0 - Build Report

**Generated**: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")  
**Builder**: DreamWeaver-Builder-V5.ps1  
**Version**: $ScriptVersion  
**Language**: $Language  

## Build Summary

**Status**: $(if ($Validation.Valid) { " SUCCESS" } else { " FAILED" })  
**Files Generated**: $($GeneratedCode.Count)  
**Test Files**: $($TestFiles.Count)  
**Validation**: $(if ($Validation.Valid) { "PASSED" } else { "FAILED" })  

## Specification Analysis

**Title**: $($Specification.Title)  
**Description**: $($Specification.Description)  
**Requirements**: $($Specification.Requirements.Count)  
**Classes**: $($Specification.Classes.Count)  
**Functions**: $($Specification.Functions.Count)  

## Generated Code

| File | Type | Size |
|------|------|------|
"@

    foreach ($codeFile in $GeneratedCode) {
        $report += "n| $($codeFile.FileName) | $($codeFile.Type) | $([math]::Round($codeFile.Content.Length/1KB, 1))KB |"
    }
    
    if ($TestFiles.Count -gt 0) {
        $report += @"

## Test Files

| File | Type | Size |
|------|------|------|
"@
        foreach ($testFile in $TestFiles) {
            $report += "n| $($testFile.FileName) | $($testFile.Type) | $([math]::Round($testFile.Size/1KB, 1))KB |"
        }
    }
    
    if (!$Validation.Valid) {
        $report += @"

## Validation Issues

"@
        foreach ($issue in $Validation.Issues) {
            $report += "n### $($issue.FileName)n"
            foreach ($problem in $issue.Issues) {
                $report += "- $problemn"
            }
        }
    }
    
    $report += @"

## Next Steps

1. Review generated code for accuracy
2. Implement missing functionality
3. Add proper error handling
4. Enhance with real business logic
5. Run tests to validate functionality

---

*Report generated by DreamWeaver-Builder-V5.ps1 - Code Generation Framework*  
*Agent Exo-Suit V5.0 "Builder of Dreams" - Phase 1 Foundation*
"@

    try {
        Set-Content -Path $reportFile -Value $report -Encoding UTF8
        Write-Log "Build report generated: $reportFile" "INFO"
        return $reportFile
    }
    catch {
        Write-Log "Error generating build report: $($_.Exception.Message)" "ERROR"
        return $null
    }
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

function Main {
    Write-Log "Starting DreamWeaver Builder V5.0 - Code Generation Framework" "INFO"
    
    try {
        # Initialize builder
        Initialize-Builder
        
        # Parse specification if provided
        $specification = $null
        if ($InputFile -and (Test-Path $InputFile)) {
            $specification = Parse-MarkdownSpecification -FilePath $InputFile
            if (!$specification) {
                Write-Log "Failed to parse specification file" "ERROR"
                return $null
            }
        } else {
            # Create sample specification for demonstration
            Write-Log "No input file provided, creating sample specification" "INFO"
            $specification = @{
                Title = "Sample Generated System"
                Description = "A sample system generated by DreamWeaver Builder V5.0"
                Requirements = @("Must be functional", "Should be well-structured", "Will be extensible")
                Classes = @(
                    @{ Name = "SampleClass"; Content = "A sample class for demonstration" }
                )
                Functions = @(
                    @{ Name = "sample_function"; Content = "A sample function for demonstration" }
                )
            }
        }
        
        # Generate code from specification
        $generatedCode = Generate-CodeFromSpec -Specification $specification -Language $Language
        if (!$generatedCode) {
            Write-Log "Failed to generate code from specification" "ERROR"
            return $null
        }
        
        # Write generated code to files
        $writtenFiles = Write-GeneratedCode -GeneratedCode $generatedCode
        
        # Generate tests if requested
        $testFiles = @()
        if ($GenerateTests) {
            $testFiles = Generate-Tests -GeneratedCode $generatedCode -Language $Language
        }
        
        # Validate generated code
        $validation = Validate-GeneratedCode -GeneratedCode $generatedCode
        
        # Generate build report
        $reportFile = Generate-BuildReport -Specification $specification -GeneratedCode $generatedCode -TestFiles $testFiles -Validation $validation
        
        # Summary output
        Write-Log "Code Generation Complete" "INFO"
        Write-Log "Files Generated: $($writtenFiles.Count)" "INFO"
        Write-Log "Test Files: $($testFiles.Count)" "INFO"
        Write-Log "Validation: $(if ($validation.Valid) { 'PASSED' } else { 'FAILED' })" "INFO"
        
        return @{
            Specification = $specification
            GeneratedCode = $generatedCode
            WrittenFiles = $writtenFiles
            TestFiles = $testFiles
            Validation = $validation
            ReportFile = $reportFile
            Summary = @{
                FilesGenerated = $writtenFiles.Count
                TestFilesGenerated = $testFiles.Count
                ValidationPassed = $validation.Valid
                TotalIssues = $validation.Summary.Issues
            }
        }
    }
    catch {
        Write-Log "Critical error in main execution: $($_.Exception.Message)" "ERROR"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" "ERROR"
        return $null
    }
}

# =============================================================================
# SCRIPT EXECUTION
# =============================================================================

if ($MyInvocation.InvocationName -ne ".") {
    # Script was called directly
    $results = Main
    
    if ($results) {
        Write-Host "nCode Generation Complete!" -ForegroundColor Green
        Write-Host "Files Generated: $($results.Summary.FilesGenerated)" -ForegroundColor Cyan
        Write-Host "Test Files: $($results.Summary.TestFilesGenerated)" -ForegroundColor Cyan
        Write-Host "Validation: $(if ($results.Summary.ValidationPassed) { 'PASSED' } else { 'FAILED' })" -ForegroundColor $(if ($results.Summary.ValidationPassed) { 'Green' } else { 'Red' })
        
        if ($results.ReportFile) {
            Write-Host "nBuild report generated: $($results.ReportFile)" -ForegroundColor Green
        }
        
        Write-Host "nGenerated files are in: $OutputPath" -ForegroundColor Green
    } else {
        Write-Host "Code generation failed!" -ForegroundColor Red
        exit 1
    }
} else {
    # Script was dot-sourced
    Write-Log "DreamWeaver-Builder-V5.ps1 loaded as module" "INFO"
}
