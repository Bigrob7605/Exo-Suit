{
  "hash": "cbabe25881d87e9ed436471b1ecc35d3e67c173bfc3c60759f572c97b09f9f58",
  "timestamp": "2025-08-05T18:44:36.905671",
  "domain": "coding_agentic",
  "type": "missing_function",
  "code": "import numpy as np\nimport pandas as pd\nfrom scipy import stats\nimport hashlib\nimport os\nfrom typing import Dict, Any, Union\n\ndef is_safe_str(s: str) -> bool:\n    \"\"\"\n    Check if a string can be safely used in a hash function.\n    \"\"\"\n    return all(c.isalnum() or c == '_' for c in s)\n\ndef sanitize_dataframe(df: pd.DataFrame, message: str) -> pd.DataFrame:\n    \"\"\"\n    Sanitize user-provided data before processing it.\n    \"\"\"\n    sanitized_df = df.copy()\n    for col in sanitized_df.columns:\n        if not all(isinstance(sanitized_df[col], (str, int, float)) and is_safe_str(sanitized_df[col].astype(str).str.cat())):\n            raise ValueError(f\"{message}: the provided dataframe '{col}' contains invalid characters.\")\n    return sanitized_df\n\ndef coding_agentic_bulletproof_test(data: Union[pd.DataFrame, None] = None, truth_table: Union[pd.DataFrame, None] = None) -> Dict[str, Any]:\n    \"\"\"\n    Corrected coding_agentic domain test with bulletproof statistical analysis.\n    Provides safer data handling and customized error messages.\n    \"\"\"\n    if not all([data is not None, truth_table is not None]):\n        raise ValueError(\"Both 'data' and 'truth_table' must be provided.\")\n\n    sanitized_data = sanitize_dataframe(data, \"Data provided to the function\")\n    sanitized_truth_table = sanitize_dataframe(truth_table, \"Truth table provided to the function\")\n\n    try:\n        data_hash = hashlib.sha256(sanitized_data.to_bytes()).hexdigest()\n        truth_table_hash = hashlib.sha256(sanitized_truth_table.to_bytes()).hexdigest()\n\n        if data_hash != truth_table_hash:\n            raise ValueError(\"Data hashes do not match\")\n\n        # Assuming 'data' and 'truth_table' have compatible columns and indices\n        pass_criteria = np.allclose(sanitized_data, sanitized_truth_table)\n\n        if pass_criteria:\n            effect_size, _, _, _ = stats.ttest_ind(sanitized_data[\"pass\"].values, sanitized_truth_table[\"pass\"].values)\n            power = stats.ttest_ind(\n                np.concatenate([sanitized_data[\"pass\"].values[sanitized_data[\"fail\"]], sanitized_truth_table[\"pass\"].values[sanitized_truth_table[\"fail\"]]]),\n                np.concatenate([sanitized_data[\"pass\"].values[~sanitized_data[\"fail\"]], sanitized_truth_table[\"pass\"].values[~sanitized_truth_table[\"fail\"]]]),\n                axis=0,\n            )\n        else:\n            effect_size = np.nan\n            power = np.nan\n\n        return {\n            \"test_name\": \"coding_agentic_bulletproof_test\",\n            \"pass_fail\": {\"criteria\": pass_criteria},\n            \"metrics\": {\"effect_size\": effect_size, \"power\": power},\n            \"evidence\": {\"data_hash\": data_hash}\n        }\n    except ValueError as e:\n        return {\n            \"error\": str(e),\n            \"test_failed\": True,\n        }",
  "description": "Missing bulletproof test function for coding_agentic",
  "status": "pending_review",
  "reviewer": null,
  "approved": false
}